<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    
    <!-- PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="DragonIsle" />
    
    <link rel="manifest" href="/manifest.webmanifest" />
    <link rel="icon" href="/icons/icon-192.svg" />
    <title>Dragon Isle ‚Äî Mobile</title>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        touch-action: none;
      }
      
      body { 
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: #000;
        color: #fff;
        position: fixed;
        width: 100%;
        height: 100vh;
        overflow: hidden;
      }
      
      /* Connect Screen */
      #connectScreen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
      }
      
      #connectScreen.hidden {
        display: none;
      }
      
      .connect-container {
        text-align: center;
        padding: 2rem;
        max-width: 400px;
      }
      
      .logo {
        font-size: 3rem;
        margin-bottom: 1rem;
      }
      
      .title {
        font-size: 2rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
        background: linear-gradient(45deg, #3b82f6, #8b5cf6);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }
      
      .connect-btn {
        background: linear-gradient(45deg, #3b82f6, #6366f1);
        border: none;
        color: white;
        padding: 1rem 3rem;
        font-size: 1.2rem;
        font-weight: 600;
        border-radius: 12px;
        cursor: pointer;
        margin-top: 2rem;
        box-shadow: 0 8px 32px rgba(99, 102, 241, 0.3);
      }
      
      .connect-btn:active {
        transform: scale(0.98);
      }
      
      .status-text {
        margin-top: 1rem;
        color: #94a3b8;
      }
      
      /* Game Screen */
      #gameScreen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: none;
        background: #000;
      }
      
      #gameScreen.active {
        display: block;
      }
      
      #gameCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        image-rendering: pixelated;
        background: #1e40af;
      }
      
      /* HUD */
      .hud {
        position: absolute;
        top: env(safe-area-inset-top, 10px);
        left: env(safe-area-inset-left, 10px);
        right: env(safe-area-inset-right, 10px);
        display: flex;
        justify-content: space-between;
        pointer-events: none;
        padding: 10px;
      }
      
      .hud-item {
        background: rgba(0, 0, 0, 0.7);
        padding: 8px 12px;
        border-radius: 8px;
        font-size: 14px;
        color: #fff;
        backdrop-filter: blur(10px);
      }
      
      .coordinates {
        font-family: monospace;
      }
      
      /* Virtual Joystick */
      #joystickContainer {
        position: absolute;
        bottom: env(safe-area-inset-bottom, 30px);
        left: env(safe-area-inset-left, 30px);
        width: 120px;
        height: 120px;
        opacity: 0.8;
      }
      
      #joystickBase {
        position: absolute;
        width: 120px;
        height: 120px;
        background: radial-gradient(circle, rgba(59, 130, 246, 0.3), rgba(59, 130, 246, 0.1));
        border: 2px solid rgba(59, 130, 246, 0.5);
        border-radius: 50%;
      }
      
      #joystickKnob {
        position: absolute;
        width: 50px;
        height: 50px;
        background: radial-gradient(circle, #3b82f6, #1d4ed8);
        border-radius: 50%;
        top: 35px;
        left: 35px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }
      
      /* Action Buttons */
      .action-buttons {
        position: absolute;
        bottom: env(safe-area-inset-bottom, 30px);
        right: env(safe-area-inset-right, 30px);
        display: flex;
        gap: 15px;
      }
      
      .action-btn {
        width: 60px;
        height: 60px;
        background: rgba(59, 130, 246, 0.3);
        border: 2px solid rgba(59, 130, 246, 0.6);
        border-radius: 50%;
        color: white;
        font-size: 12px;
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(10px);
      }
      
      .action-btn:active {
        background: rgba(59, 130, 246, 0.6);
        transform: scale(0.95);
      }
      
      /* Chat */
      #chatContainer {
        position: absolute;
        bottom: env(safe-area-inset-bottom, 160px);
        left: env(safe-area-inset-left, 10px);
        right: env(safe-area-inset-right, 10px);
        max-height: 150px;
        pointer-events: none;
      }
      
      #chatMessages {
        padding: 5px;
        max-height: 120px;
        overflow-y: auto;
        pointer-events: auto;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 8px;
        font-size: 12px;
        color: #fff;
        backdrop-filter: blur(10px);
      }
      
      .chat-message {
        margin-bottom: 4px;
        word-wrap: break-word;
      }
      
      .chat-local { color: #fff; }
      .chat-world { color: #3b82f6; }
      .chat-system { color: #10b981; font-style: italic; }
      
      #chatInput {
        display: none;
        margin-top: 5px;
        padding: 8px;
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid rgba(59, 130, 246, 0.5);
        border-radius: 8px;
        color: white;
        font-size: 14px;
        width: 100%;
        pointer-events: auto;
      }
      
      #chatInput.active {
        display: block;
      }
      
      /* Menu Button */
      #menuBtn {
        position: absolute;
        top: env(safe-area-inset-top, 10px);
        right: env(safe-area-inset-right, 10px);
        width: 40px;
        height: 40px;
        background: rgba(0, 0, 0, 0.7);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        color: white;
        font-size: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(10px);
        z-index: 100;
      }
      
      /* Debug Info */
      #debugInfo {
        position: absolute;
        top: env(safe-area-inset-top, 60px);
        right: env(safe-area-inset-right, 10px);
        background: rgba(0, 0, 0, 0.8);
        padding: 8px;
        border-radius: 8px;
        font-size: 11px;
        font-family: monospace;
        color: #0f0;
        max-width: 200px;
        display: none;
      }
      
      #debugInfo.active {
        display: block;
      }
    </style>
  </head>
  <body>
    <!-- Connect Screen -->
    <div id="connectScreen">
      <div class="connect-container">
        <div class="logo">üêâ</div>
        <div class="title">Dragon Isle</div>
        <div class="status-text" id="statusText">Touch to connect</div>
        <button class="connect-btn" id="connectBtn">Enter World</button>
      </div>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen">
      <canvas id="gameCanvas"></canvas>
      
      <!-- HUD -->
      <div class="hud">
        <div class="hud-item">
          <span id="playerName">Player</span>
        </div>
        <div class="hud-item coordinates">
          <span id="coords">0, 0</span>
        </div>
      </div>
      
      <!-- Virtual Joystick -->
      <div id="joystickContainer">
        <div id="joystickBase"></div>
        <div id="joystickKnob"></div>
      </div>
      
      <!-- Action Buttons -->
      <div class="action-buttons">
        <div class="action-btn" id="interactBtn">INT</div>
        <div class="action-btn" id="chatBtn">CHAT</div>
      </div>
      
      <!-- Chat -->
      <div id="chatContainer">
        <div id="chatMessages"></div>
        <input type="text" id="chatInput" placeholder="Type message..." />
      </div>
      
      <!-- Menu Button -->
      <div id="menuBtn">‚ò∞</div>
      
      <!-- Debug Info -->
      <div id="debugInfo"></div>
    </div>

    <script>
      // Game State
      const gameState = {
        socket: null,
        connected: false,
        world: null,
        player: {
          x: 5000,
          y: 5000,
          speed: 3,
          chunk: null,
          biome: 'ocean'
        },
        camera: {
          x: 5000,
          y: 5000,
          zoom: 2
        },
        otherPlayers: new Map(),
        movement: { x: 0, y: 0 },
        joystick: {
          active: false,
          startX: 0,
          startY: 0
        },
        canvas: null,
        ctx: null,
        animationFrame: null,
        lastUpdate: Date.now()
      };

      // Biome colors
      const BIOME_COLORS = {
        ocean: '#1e40af',
        coast: '#3b82f6',
        beach: '#fbbf24',
        grassland: '#22c55e',
        forest: '#15803d',
        rainforest: '#14532d',
        desert: '#f59e0b',
        tundra: '#e0e7ff',
        mountain: '#6b7280',
        peak: '#f3f4f6',
        volcanic: '#991b1b',
        reef: '#06b6d4',
        unknown: '#d946ef'
      };

      // Initialize
      document.addEventListener('DOMContentLoaded', () => {
        setupConnectScreen();
        setupGameControls();
        
        // Prevent default touch behaviors
        document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
        document.addEventListener('gesturestart', (e) => e.preventDefault());
      });

      function setupConnectScreen() {
        const connectBtn = document.getElementById('connectBtn');
        const statusText = document.getElementById('statusText');
        
        connectBtn.addEventListener('click', async () => {
          statusText.textContent = 'Connecting...';
          connectBtn.disabled = true;
          
          try {
            // Load world manifest
            const response = await fetch('/api/worlds/alpha/manifest?compact=1');
            if (!response.ok) throw new Error('Failed to load world');
            
            gameState.world = await response.json();
            
            // Connect to socket
            connectToSocket();
            
          } catch (error) {
            statusText.textContent = 'Connection failed';
            connectBtn.disabled = false;
            console.error('Connect error:', error);
          }
        });
      }

      function connectToSocket() {
        const statusText = document.getElementById('statusText');
        
        gameState.socket = io('/world/alpha', {
          transports: ['websocket'],
          reconnection: true
        });
        
        gameState.socket.on('connect', () => {
          console.log('Connected to server');
          gameState.connected = true;
          enterGame();
        });
        
        gameState.socket.on('disconnect', () => {
          console.log('Disconnected from server');
          gameState.connected = false;
        });
        
        gameState.socket.on('player-moved', (data) => {
          if (data.playerId !== gameState.socket.id) {
            gameState.otherPlayers.set(data.playerId, data);
          }
        });
        
        gameState.socket.on('player-left', (data) => {
          gameState.otherPlayers.delete(data.playerId);
        });
        
        gameState.socket.on('chunk-state', (data) => {
          gameState.player.chunk = data.chunk;
          updateDebugInfo();
        });
        
        gameState.socket.on('chat-message', (data) => {
          addChatMessage(data.message, data.channel, data.playerName);
        });
      }

      function enterGame() {
        document.getElementById('connectScreen').classList.add('hidden');
        document.getElementById('gameScreen').classList.add('active');
        
        initCanvas();
        startGameLoop();
      }

      function initCanvas() {
        gameState.canvas = document.getElementById('gameCanvas');
        gameState.ctx = gameState.canvas.getContext('2d');
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
          setTimeout(resizeCanvas, 100);
        });
      }

      function resizeCanvas() {
        gameState.canvas.width = window.innerWidth;
        gameState.canvas.height = window.innerHeight;
      }

      function setupGameControls() {
        setupJoystick();
        setupActionButtons();
        setupChat();
        setupMenu();
      }

      function setupJoystick() {
        const container = document.getElementById('joystickContainer');
        const knob = document.getElementById('joystickKnob');
        const base = document.getElementById('joystickBase');
        
        const handleStart = (e) => {
          e.preventDefault();
          const touch = e.touches ? e.touches[0] : e;
          const rect = base.getBoundingClientRect();
          
          gameState.joystick.active = true;
          gameState.joystick.startX = rect.left + rect.width / 2;
          gameState.joystick.startY = rect.top + rect.height / 2;
          
          handleMove(e);
        };
        
        const handleMove = (e) => {
          if (!gameState.joystick.active) return;
          e.preventDefault();
          
          const touch = e.touches ? e.touches[0] : e;
          const dx = touch.clientX - gameState.joystick.startX;
          const dy = touch.clientY - gameState.joystick.startY;
          
          const distance = Math.sqrt(dx * dx + dy * dy);
          const maxDistance = 35;
          
          let knobX = dx;
          let knobY = dy;
          
          if (distance > maxDistance) {
            const angle = Math.atan2(dy, dx);
            knobX = Math.cos(angle) * maxDistance;
            knobY = Math.sin(angle) * maxDistance;
          }
          
          knob.style.transform = `translate(${knobX}px, ${knobY}px)`;
          
          // Set movement vector
          gameState.movement.x = knobX / maxDistance;
          gameState.movement.y = knobY / maxDistance;
        };
        
        const handleEnd = (e) => {
          e.preventDefault();
          gameState.joystick.active = false;
          knob.style.transform = 'translate(0, 0)';
          gameState.movement.x = 0;
          gameState.movement.y = 0;
        };
        
        container.addEventListener('touchstart', handleStart);
        container.addEventListener('touchmove', handleMove);
        container.addEventListener('touchend', handleEnd);
        container.addEventListener('touchcancel', handleEnd);
      }

      function setupActionButtons() {
        document.getElementById('interactBtn').addEventListener('click', () => {
          if (gameState.socket && gameState.connected) {
            gameState.socket.emit('interact');
            addChatMessage('Interacting...', 'system');
          }
        });
        
        document.getElementById('chatBtn').addEventListener('click', () => {
          const chatInput = document.getElementById('chatInput');
          chatInput.classList.toggle('active');
          if (chatInput.classList.contains('active')) {
            chatInput.focus();
          }
        });
      }

      function setupChat() {
        const chatInput = document.getElementById('chatInput');
        
        chatInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            const message = chatInput.value.trim();
            if (message && gameState.socket) {
              gameState.socket.emit('chat-message', {
                channel: 'local',
                message: message
              });
              chatInput.value = '';
              chatInput.classList.remove('active');
            }
          } else if (e.key === 'Escape') {
            chatInput.value = '';
            chatInput.classList.remove('active');
          }
        });
      }

      function setupMenu() {
        document.getElementById('menuBtn').addEventListener('click', () => {
          const debugInfo = document.getElementById('debugInfo');
          debugInfo.classList.toggle('active');
        });
      }

      function addChatMessage(message, channel = 'local', playerName = '') {
        const chatMessages = document.getElementById('chatMessages');
        const msgElement = document.createElement('div');
        msgElement.className = `chat-message chat-${channel}`;
        
        if (playerName) {
          msgElement.textContent = `${playerName}: ${message}`;
        } else {
          msgElement.textContent = message;
        }
        
        chatMessages.appendChild(msgElement);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        // Remove old messages
        while (chatMessages.children.length > 50) {
          chatMessages.removeChild(chatMessages.firstChild);
        }
      }

      function updateDebugInfo() {
        const debugInfo = document.getElementById('debugInfo');
        debugInfo.innerHTML = `
          FPS: ${Math.round(1000 / (Date.now() - gameState.lastUpdate))}<br>
          Chunk: ${gameState.player.chunk || 'N/A'}<br>
          Players: ${gameState.otherPlayers.size}<br>
          Biome: ${gameState.player.biome}<br>
          Zoom: ${gameState.camera.zoom.toFixed(1)}
        `;
      }

      function startGameLoop() {
        function gameLoop() {
          const now = Date.now();
          const dt = (now - gameState.lastUpdate) / 1000;
          gameState.lastUpdate = now;
          
          update(dt);
          render();
          
          gameState.animationFrame = requestAnimationFrame(gameLoop);
        }
        
        gameLoop();
      }

      function update(dt) {
        // Update player position
        if (gameState.movement.x !== 0 || gameState.movement.y !== 0) {
          const speed = gameState.player.speed * 60;
          gameState.player.x += gameState.movement.x * speed * dt;
          gameState.player.y += gameState.movement.y * speed * dt;
          
          // Emit movement
          if (gameState.socket && gameState.connected) {
            gameState.socket.emit('move-player', {
              x: gameState.player.x,
              y: gameState.player.y
            });
          }
        }
        
        // Smooth camera follow
        gameState.camera.x += (gameState.player.x - gameState.camera.x) * 0.1;
        gameState.camera.y += (gameState.player.y - gameState.camera.y) * 0.1;
        
        // Update coordinates display
        document.getElementById('coords').textContent = 
          `${Math.floor(gameState.player.x)}, ${Math.floor(gameState.player.y)}`;
      }

      function render() {
        const { canvas, ctx } = gameState;
        if (!ctx) return;
        
        // Clear
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Save context
        ctx.save();
        
        // Camera transform
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.scale(gameState.camera.zoom, gameState.camera.zoom);
        ctx.translate(-gameState.camera.x, -gameState.camera.y);
        
        // Draw world (simplified)
        drawWorld();
        
        // Draw other players
        drawOtherPlayers();
        
        // Draw player
        drawPlayer();
        
        // Restore context
        ctx.restore();
      }

      function drawWorld() {
        const { ctx, camera } = gameState;
        const tileSize = 32;
        
        // Calculate visible tiles
        const startX = Math.floor((camera.x - 400) / tileSize);
        const endX = Math.ceil((camera.x + 400) / tileSize);
        const startY = Math.floor((camera.y - 400) / tileSize);
        const endY = Math.ceil((camera.y + 400) / tileSize);
        
        // Draw simple grid with biome colors
        for (let x = startX; x <= endX; x++) {
          for (let y = startY; y <= endY; y++) {
            // Simple biome determination based on distance from center
            const dist = Math.sqrt(x * x + y * y);
            let biome = 'ocean';
            
            if (dist < 100) biome = 'grassland';
            else if (dist < 150) biome = 'forest';
            else if (dist < 200) biome = 'coast';
            
            ctx.fillStyle = BIOME_COLORS[biome];
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
          }
        }
        
        // Update player biome
        const playerTileX = Math.floor(gameState.player.x / tileSize);
        const playerTileY = Math.floor(gameState.player.y / tileSize);
        const playerDist = Math.sqrt(playerTileX * playerTileX + playerTileY * playerTileY);
        
        if (playerDist < 100) gameState.player.biome = 'grassland';
        else if (playerDist < 150) gameState.player.biome = 'forest';
        else if (playerDist < 200) gameState.player.biome = 'coast';
        else gameState.player.biome = 'ocean';
      }

      function drawOtherPlayers() {
        const { ctx } = gameState;
        
        gameState.otherPlayers.forEach((player) => {
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(player.x, player.y, 8, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw name
          ctx.fillStyle = '#fff';
          ctx.font = '12px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(player.playerName || 'Player', player.x, player.y - 15);
        });
      }

      function drawPlayer() {
        const { ctx, player } = gameState;
        
        // Draw player as a circle
        ctx.fillStyle = '#3b82f6';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(player.x, player.y, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Draw direction indicator
        if (gameState.movement.x !== 0 || gameState.movement.y !== 0) {
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(player.x, player.y);
          ctx.lineTo(
            player.x + gameState.movement.x * 20,
            player.y + gameState.movement.y * 20
          );
          ctx.stroke();
        }
      }

      // Handle pinch zoom
      let lastTouchDistance = 0;
      
      document.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
        }
      });
      
      document.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (lastTouchDistance > 0) {
            const scale = distance / lastTouchDistance;
            gameState.camera.zoom *= scale;
            gameState.camera.zoom = Math.max(0.5, Math.min(4, gameState.camera.zoom));
          }
          
          lastTouchDistance = distance;
        }
      });
      
      document.addEventListener('touchend', (e) => {
        if (e.touches.length < 2) {
          lastTouchDistance = 0;
        }
      });
    </script>
  </body>
</html>