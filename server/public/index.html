<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Multiplayer Dragon Isle — Test Client</title>
    <!-- Cache bust: v12:37 -->
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      
      body {
        font-family: system-ui, -apple-system, sans-serif;
        height: 100vh;
        overflow: hidden;
        background: #1a1a1a;
        display: flex;
        flex-direction: column;
      }
      
      /* Header bar */
      #header {
        background: #2a2a2a;
        border-bottom: 1px solid #444;
        padding: 0.75rem 1rem;
        display: flex;
        align-items: center;
        gap: 1rem;
        flex-shrink: 0;
      }
      
      #header h1 {
        font-size: 1.2rem;
        color: #fff;
        font-weight: 500;
        margin-right: auto;
      }
      
      #header input, #header button {
        padding: 0.4rem 0.8rem;
        border: 1px solid #444;
        background: #1a1a1a;
        color: #fff;
        border-radius: 4px;
      }
      
      #header button {
        background: #3b82f6;
        border: none;
        cursor: pointer;
        font-weight: 500;
      }
      
      #header button:hover {
        background: #2563eb;
      }
      
      #status {
        padding: 0.3rem 0.6rem;
        border-radius: 4px;
        font-size: 0.9rem;
        background: #333;
        color: #888;
      }
      
      #status.connected {
        background: #064e3b;
        color: #10b981;
      }
      
      /* Game canvas area */
      #gameContainer {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        background: radial-gradient(circle at center, #2a2a2a 0%, #1a1a1a 100%);
      }
      
      canvas {
        border: 2px solid #333;
        box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
        background: #000;
        max-width: 100%;
        max-height: 100%;
      }
      
      /* Debug controls overlay */
      #debugControls {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: rgba(42, 42, 42, 0.9);
        padding: 0.5rem;
        border-radius: 4px;
        display: flex;
        gap: 0.5rem;
      }
      
      #debugControls button {
        padding: 0.3rem 0.6rem;
        background: #444;
        color: #fff;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        font-size: 0.85rem;
      }
      
      #debugControls button:hover {
        background: #555;
      }
      
      /* Chat footer */
      #chatPanel {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: #2a2a2a;
        border-top: 1px solid #444;
        transition: transform 0.3s ease;
        z-index: 100;
      }
      
      #chatPanel.collapsed {
        transform: translateY(calc(100% - 40px));
      }
      
      #chatToggle {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 40px;
        background: #333;
        display: flex;
        align-items: center;
        padding: 0 1rem;
        cursor: pointer;
        user-select: none;
      }
      
      #chatToggle:hover {
        background: #3a3a3a;
      }
      
      #chatToggle span {
        color: #fff;
        font-size: 0.9rem;
        font-weight: 500;
      }
      
      #chatToggle .arrow {
        margin-left: auto;
        color: #888;
        transition: transform 0.3s;
      }
      
      #chatPanel.collapsed .arrow {
        transform: rotate(180deg);
      }
      
      #chatContent {
        padding: 0 1rem 1rem;
        padding-top: 50px;
        height: 250px;
        display: flex;
        flex-direction: column;
      }
      
      #log {
        flex: 1;
        overflow-y: auto;
        background: #1a1a1a;
        color: #0f0;
        padding: 0.5rem;
        border-radius: 4px;
        font-family: 'Courier New', monospace;
        font-size: 0.85rem;
        margin-bottom: 0.5rem;
        white-space: pre-wrap;
        word-wrap: break-word;
      }
      
      #chatInput {
        display: flex;
        gap: 0.5rem;
      }
      
      #chatInput select, #chatInput input {
        padding: 0.4rem;
        background: #1a1a1a;
        border: 1px solid #444;
        color: #fff;
        border-radius: 4px;
      }
      
      #chatInput select {
        width: 100px;
      }
      
      #chatInput input {
        flex: 1;
      }
      
      /* Controls hint */
      #controls {
        position: absolute;
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        font-size: 0.9rem;
        pointer-events: none;
        transition: opacity 0.3s;
      }
      
      #chatPanel.collapsed ~ #gameContainer #controls {
        bottom: 50px;
      }
      
      /* Minimap styles */
      #minimapContainer {
        position: absolute;
        top: 1rem;
        left: 1rem;
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid #333;
        border-radius: 8px;
        overflow: hidden;
        transition: all 0.3s ease;
        z-index: 50;
      }
      
      #minimapContainer.hidden {
        opacity: 0;
        pointer-events: none;
        transform: scale(0.8);
      }
      
      #minimapContainer.normal {
        width: 200px;
        height: 200px;
      }
      
      #minimapContainer.fullscreen {
        width: 400px;
        height: 400px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
        border: 3px solid #666;
        box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
      }
      
      #minimap {
        width: 100%;
        height: calc(100% - 30px);
        display: block;
      }
      
      #minimapHeader {
        height: 30px;
        background: #2a2a2a;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 0.5rem;
        font-size: 0.8rem;
        color: #fff;
        cursor: pointer;
        user-select: none;
      }
      
      #minimapHeader:hover {
        background: #333;
      }
      
      #minimapTitle {
        font-weight: 500;
      }
      
      #minimapToggle {
        color: #aaa;
        font-size: 0.7rem;
      }
      
      /* Fullscreen overlay */
      #minimapContainer.fullscreen::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: -1;
      }
    </style>
  </head>
  <body>
    <!-- Header with connection controls -->
    <div id="header">
      <h1>Dragon Isle — Multiplayer Test</h1>
      <label>World: <input id="seed" value="alpha" size="10" /></label>
      <button id="connect">Connect</button>
      <span id="status">disconnected</span>
    </div>
    
    <!-- Main game area -->
    <div id="gameContainer">
      <canvas id="view"></canvas>
      
      <!-- Minimap -->
      <div id="minimapContainer" class="normal">
        <div id="minimapHeader">
          <span id="minimapTitle">World Map</span>
          <span id="minimapToggle">Click to toggle</span>
        </div>
        <canvas id="minimap"></canvas>
      </div>
      
      <!-- Debug controls -->
      <div id="debugControls">
        <button id="interact">Interact POI</button>
        <button id="breed">Breed Demo</button>
        <button id="ignoreTerrainBtn">Ignore Terrain: Off</button>
        <button id="regenPoi">Regenerate POI</button>
      </div>
      
      <!-- Movement controls hint -->
      <div id="controls">WASD: Move • M: Toggle minimap • Mouse wheel: Zoom • +/-: Zoom • 0: Reset zoom</div>
    </div>
    
    <!-- Collapsible chat panel -->
    <div id="chatPanel">
      <div id="chatToggle">
        <span>Chat & Logs</span>
        <span class="arrow">▼</span>
      </div>
      <div id="chatContent">
        <pre id="log">Welcome to Dragon Isle Multiplayer Test Client
Click "Connect" to join world "alpha"
</pre>
        <div id="chatInput">
          <select id="channel">
            <option>local</option>
            <option>world</option>
            <option>guild</option>
          </select>
          <input id="chat" placeholder="Type message and press Enter" />
        </div>
      </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      // Global variables - declare at the very top
      let socket;
      let me = { x: 0, y: 0, userId: null };
      const others = new Map();
      let worldData = null;
      let minimapState = 'normal'; // 'hidden', 'normal', 'fullscreen'
      let ignoreTerrain = false; // testing toggle
      
      // Game state management
      let gameState = {
        currentPOI: null, // null = overworld, string = POI interior
        poiInteriors: new Map(), // cached interior layouts
        nearbyPOI: null, // POI player is close to (for interaction prompts)
        overworldPosition: null // Store player position before entering POI
      };
      
      // Camera system with deadzone and zoom
      const camera = { x: 0, y: 0, zoom: 1.0 };
      const BASE_DEADZONE_WIDTH = 100;  // Base width of the deadzone at 1.0x zoom
      const BASE_DEADZONE_HEIGHT = 100; // Base height of the deadzone at 1.0x zoom
      const CAMERA_SMOOTHING = 0.1; // Smooth camera movement (0-1, higher = faster)
      const MIN_ZOOM = 0.3;  // Minimum zoom level (zoomed out)
      const MAX_ZOOM = 3.0;  // Maximum zoom level (zoomed in)
      const ZOOM_SPEED = 0.1; // Zoom change per wheel tick

      const canvas = document.getElementById('view');
      const ctx = canvas.getContext('2d');
      
      // Minimap setup
      const minimapCanvas = document.getElementById('minimap');
      const minimapCtx = minimapCanvas.getContext('2d');
      
      // Resize canvas to fill container
      function resizeCanvas() {
        const canvas = document.getElementById('view');
        const container = document.getElementById('gameContainer');
        const maxWidth = container.clientWidth - 40;
        const maxHeight = container.clientHeight - 40;
        
        // Set a good default size, but scale to fit
        const targetWidth = 1024;
        const targetHeight = 768;
        
        const scale = Math.min(maxWidth / targetWidth, maxHeight / targetHeight, 1);
        canvas.width = targetWidth * scale;
        canvas.height = targetHeight * scale;
        
        // Resize minimap canvas
        resizeMinimap();
      }
      
      function resizeMinimap() {
        const container = document.getElementById('minimapContainer');
        const canvas = document.getElementById('minimap');
        
        if (minimapState === 'hidden') return;
        
        const rect = container.getBoundingClientRect();
        const headerHeight = 30;
        canvas.width = rect.width;
        canvas.height = rect.height - headerHeight;
      }
      
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
      
      // Chat panel toggle
      const chatPanel = document.getElementById('chatPanel');
      const chatToggle = document.getElementById('chatToggle');
      chatToggle.addEventListener('click', () => {
        chatPanel.classList.toggle('collapsed');
      });
      
      // Start with chat collapsed
      chatPanel.classList.add('collapsed');
      
      // Minimap state toggling
      function toggleMinimapState() {
        const container = document.getElementById('minimapContainer');
        const title = document.getElementById('minimapTitle');
        const toggle = document.getElementById('minimapToggle');
        
        // Cycle through states: normal -> fullscreen -> hidden -> normal
        switch (minimapState) {
          case 'normal':
            minimapState = 'fullscreen';
            container.className = 'fullscreen';
            title.textContent = 'World Map - Fullscreen';
            toggle.textContent = 'Click to hide';
            break;
          case 'fullscreen':
            minimapState = 'hidden';
            container.className = 'hidden';
            title.textContent = 'World Map';
            toggle.textContent = 'Click to show';
            break;
          case 'hidden':
            minimapState = 'normal';
            container.className = 'normal';
            title.textContent = 'World Map';
            toggle.textContent = 'Click to toggle';
            break;
        }
        
        // Resize minimap canvas after state change
        setTimeout(resizeMinimap, 350); // Wait for CSS transition
      }
      
      // Add event listener to minimap header
      document.getElementById('minimapHeader').addEventListener('click', toggleMinimapState);
      
      // Keyboard shortcut for minimap (M key)
      window.addEventListener('keydown', (e) => {
        // Don't trigger when typing in chat
        if (e.target.id === 'chat') return;
        
        if (e.key.toLowerCase() === 'm') {
          e.preventDefault();
          toggleMinimapState();
        }
      });
      
      // Mouse wheel zoom controls
      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        
        const zoomDirection = e.deltaY > 0 ? -1 : 1; // Invert for natural scrolling
        const newZoom = camera.zoom + (zoomDirection * ZOOM_SPEED);
        camera.zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));
      }, { passive: false });
      
      // Keyboard zoom controls (+ and - keys)
      window.addEventListener('keydown', (e) => {
        // Don't trigger when typing in chat
        if (e.target.id === 'chat') return;
        
        if (e.key === '=' || e.key === '+') {
          e.preventDefault();
          camera.zoom = Math.min(MAX_ZOOM, camera.zoom + ZOOM_SPEED);
        } else if (e.key === '-' || e.key === '_') {
          e.preventDefault();
          camera.zoom = Math.max(MIN_ZOOM, camera.zoom - ZOOM_SPEED);
        } else if (e.key === '0') {
          e.preventDefault();
          camera.zoom = 1.0; // Reset to default zoom
        }
      });
      
      // Logging function
      const log = (m) => {
        const el = document.getElementById('log');
        el.textContent += `${new Date().toLocaleTimeString()} ${m}\n`;
        el.scrollTop = el.scrollHeight;
        
        // Flash chat panel if collapsed and new message
        if (chatPanel.classList.contains('collapsed')) {
          chatToggle.style.background = '#444';
          setTimeout(() => chatToggle.style.background = '', 200);
        }
      };

      
      // Enhanced biome system with metadata and color variance
      const BIOME_DATA = {
        ocean: {
          name: 'Ocean',
          baseColor: '#1e40af', // deep blue
          colorVariance: 0.15,
          walkable: false
        },
        beach: {
          name: 'Beach',
          baseColor: '#fbbf24', // sandy yellow
          colorVariance: 0.25,
          walkable: true
        },
        coast: {
          name: 'Coastal Plains',
          baseColor: '#84cc16', // coastal green (fixed from incorrect blue!)
          colorVariance: 0.3,
          walkable: true
        },
        grassland: {
          name: 'Grassland',
          baseColor: '#65a30d', // grass green
          colorVariance: 0.4,
          walkable: true
        },
        forest: {
          name: 'Forest',
          baseColor: '#166534', // forest green
          colorVariance: 0.35,
          walkable: true
        },
        savanna: {
          name: 'Savanna',
          baseColor: '#d97706', // warm brown (fixed from gray!)
          colorVariance: 0.4,
          walkable: true
        },
        shrubland: {
          name: 'Shrubland',
          baseColor: '#a3a65a', // olive green
          colorVariance: 0.3,
          walkable: true
        },
        hills: {
          name: 'Hills',
          baseColor: '#a16207', // brown
          colorVariance: 0.25,
          walkable: true
        },
        mountain: {
          name: 'Mountain',
          baseColor: '#6b7280', // gray
          colorVariance: 0.2,
          walkable: false
        },
        alpine: {
          name: 'Alpine',
          baseColor: '#e5e7eb', // light gray
          colorVariance: 0.15,
          walkable: true
        },
        taiga: {
          name: 'Taiga',
          baseColor: '#14532d', // dark green
          colorVariance: 0.3,
          walkable: true
        },
        tundra: {
          name: 'Tundra',
          baseColor: '#d1d5db', // light gray
          colorVariance: 0.2,
          walkable: true
        },
        desert: {
          name: 'Desert',
          baseColor: '#f59e0b', // desert orange (fixed from yellow like beach!)
          colorVariance: 0.35,
          walkable: true
        }
      };

      // Function to generate biome color with natural variance
      function getBiomeColor(biome, x, y) {
        const data = BIOME_DATA[biome];
        if (!data) return '#808080'; // fallback gray
        
        const baseColor = data.baseColor;
        const variance = data.colorVariance;
        
        if (variance === 0) return baseColor;
        
        // Use position-based deterministic variance for consistent appearance
        const hash = ((x * 73856093) ^ (y * 19349663)) % 1000000;
        const factor1 = (hash % 1000) / 1000;
        const factor2 = ((hash / 1000) % 1000) / 1000;
        
        // Parse hex color
        const hex = baseColor.slice(1);
        const r = parseInt(hex.substr(0, 2), 16);
        const g = parseInt(hex.substr(2, 2), 16);
        const b = parseInt(hex.substr(4, 2), 16);
        
        // Apply variance
        const varyAmount = variance * 60; // max variance in RGB units
        const dr = Math.floor((factor1 - 0.5) * varyAmount);
        const dg = Math.floor((factor2 - 0.5) * varyAmount);
        const db = Math.floor(((factor1 + factor2) / 2 - 0.5) * varyAmount);
        
        // Clamp to valid range
        const newR = Math.max(0, Math.min(255, r + dr));
        const newG = Math.max(0, Math.min(255, g + dg));
        const newB = Math.max(0, Math.min(255, b + db));
        
        return `rgb(${newR}, ${newG}, ${newB})`;
      }

      // Legacy color mapping for backward compatibility
      const BIOME_COLORS = Object.fromEntries(
        Object.entries(BIOME_DATA).map(([biome, data]) => [biome, data.baseColor])
      );
      
      // Unwalkable biomes (derived from metadata)
      const UNWALKABLE_BIOMES = new Set(
        Object.entries(BIOME_DATA).filter(([_, data]) => !data.walkable).map(([biome, _]) => biome)
      );
      
      // Check if a position is walkable (coordinates already in correct space)
      function isWalkable(x, y) {
        // Handle POI interiors
        if (gameState.currentPOI) {
          const interior = gameState.poiInteriors.get(gameState.currentPOI);
          if (interior) {
            // Interior coordinates are already in interior grid space
            const gridX = Math.floor(x);
            const gridY = Math.floor(y);
            
            // Check interior bounds
            const interiorWidth = interior.width || (interior.layout && interior.layout[0] ? interior.layout[0].length : 0);
            const interiorHeight = interior.height || (interior.layout ? interior.layout.length : 0);
            
            if (gridX < 0 || gridY < 0 || gridX >= interiorWidth || gridY >= interiorHeight) {
              return false;
            }
            
            // Check if the interior cell is walkable
            const cell = interior.layout[gridY] && interior.layout[gridY][gridX];
            return cell ? cell.walkable : false;
          }
        }
        
        // Handle overworld movement
        if (!worldData || !worldData.world.biomeMap) return true; // Allow movement if no world data
        if (ignoreTerrain) return true; // Testing override: ignore terrain in overworld
        
        const tileX = Math.floor(x / 8);
        const tileY = Math.floor(y / 8);
        
        if (tileX < 0 || tileY < 0 || tileX >= worldData.world.size || tileY >= worldData.world.size) {
          return false; // Outside world bounds
        }
        
        const biome = worldData.world.biomeMap[tileY] && worldData.world.biomeMap[tileY][tileX];
        return !UNWALKABLE_BIOMES.has(biome);
      }

      const POI_COLORS = {
        village: '#ef4444',        // red
        town: '#14b8a6',           // teal
        ruined_castle: '#6b7280',  // gray
        wizards_tower: '#8b5cf6', // purple
        dark_cave: '#1f2937',     // dark gray
        dragon_grounds: '#dc2626', // dark red
        lighthouse: '#f59e0b',    // orange
        ancient_circle: '#06b6d4' // cyan
      };

      function updateCamera() {
        if (gameState.currentPOI) {
          // Interior camera: directly follow player in grid coordinates
          camera.x = me.x;
          camera.y = me.y;
        } else {
          // Overworld camera: use deadzone system
          const playerScreenX = me.x - camera.x;
          const playerScreenY = me.y - camera.y;
          
          let targetCameraX = camera.x;
          let targetCameraY = camera.y;
          
          const deadzoneWidth = BASE_DEADZONE_WIDTH / camera.zoom;
          const deadzoneHeight = BASE_DEADZONE_HEIGHT / camera.zoom;
          
          if (playerScreenX < -deadzoneWidth / 2) {
            targetCameraX = me.x + deadzoneWidth / 2;
          } else if (playerScreenX > deadzoneWidth / 2) {
            targetCameraX = me.x - deadzoneWidth / 2;
          }
          
          if (playerScreenY < -deadzoneHeight / 2) {
            targetCameraY = me.y + deadzoneHeight / 2;
          } else if (playerScreenY > deadzoneHeight / 2) {
            targetCameraY = me.y - deadzoneHeight / 2;
          }
          
          camera.x += (targetCameraX - camera.x) * CAMERA_SMOOTHING;
          camera.y += (targetCameraY - camera.y) * CAMERA_SMOOTHING;
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Update camera position
        updateCamera();
        
        // Center of canvas (screen space)
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        
        // Choose rendering mode based on game state
        if (gameState.currentPOI) {
          if (gameState.currentBuilding) {
            drawBuildingInterior(cx, cy);
          } else {
            drawPOIInterior(cx, cy);
          }
        } else {
          drawOverworld(cx, cy);
        }
        
        // Common UI elements (debug info, interaction prompts)
        drawUI();
        
        // Draw minimap
        drawMinimap();
        
        // Continue the rendering loop
        requestAnimationFrame(draw);
      }
      
      function drawOverworld(cx, cy) {
        // Draw world tiles if we have world data
        if (worldData && worldData.world.biomeMap) {
          const baseTileSize = 8; // Base size of each biome tile in pixels
          const tileSize = baseTileSize * camera.zoom; // Apply zoom to tile size
          const biomeMap = worldData.world.biomeMap;
          const worldSize = worldData.world.size;
          
          // Calculate which tiles to render based on camera position and zoom
          const viewWidth = cx / camera.zoom;
          const viewHeight = cy / camera.zoom;
          const startX = Math.max(0, Math.floor((camera.x - viewWidth) / baseTileSize));
          const endX = Math.min(worldSize, Math.floor((camera.x + viewWidth) / baseTileSize) + 1);
          const startY = Math.max(0, Math.floor((camera.y - viewHeight) / baseTileSize));
          const endY = Math.min(worldSize, Math.floor((camera.y + viewHeight) / baseTileSize) + 1);
          
          // Draw biome tiles
          for (let worldY = startY; worldY < endY; worldY++) {
            for (let worldX = startX; worldX < endX; worldX++) {
              const biome = biomeMap[worldY] && biomeMap[worldY][worldX];
              if (biome && BIOME_DATA[biome]) {
                const worldPosX = worldX * baseTileSize;
                const worldPosY = worldY * baseTileSize;
                const screenX = cx + (worldPosX - camera.x) * camera.zoom;
                const screenY = cy + (worldPosY - camera.y) * camera.zoom;
                
                // Use enhanced biome color with variance
                ctx.fillStyle = getBiomeColor(biome, worldX, worldY);
                ctx.fillRect(screenX, screenY, tileSize, tileSize);
              }
            }
          }
          
          // Draw roads (before POIs for layering)
          if (worldData.world.roads) {
            ctx.strokeStyle = '#8b5a2b';
            ctx.lineWidth = Math.max(1, 2 * camera.zoom);
            ctx.lineJoin = 'round';
            for (const road of worldData.world.roads) {
              if (!road || road.length < 2) continue;
              ctx.beginPath();
              for (let i = 0; i < road.length; i++) {
                const p = road[i];
                const worldPosX = p.x * baseTileSize;
                const worldPosY = p.y * baseTileSize;
                const screenX = cx + (worldPosX - camera.x) * camera.zoom;
                const screenY = cy + (worldPosY - camera.y) * camera.zoom;
                if (i === 0) ctx.moveTo(screenX, screenY);
                else ctx.lineTo(screenX, screenY);
              }
              ctx.stroke();
            }
          }

          // Draw POIs
          if (worldData.world.pois) {
            for (const poi of worldData.world.pois) {
              const worldPosX = poi.position.x * baseTileSize;
              const worldPosY = poi.position.y * baseTileSize;
              const screenX = cx + (worldPosX - camera.x) * camera.zoom;
              const screenY = cy + (worldPosY - camera.y) * camera.zoom;
              
              // Only draw if on screen
              const poiSize = 6 * camera.zoom;
              if (screenX > -20 && screenX < canvas.width + 20 && 
                  screenY > -20 && screenY < canvas.height + 20) {
                ctx.fillStyle = POI_COLORS[poi.type] || '#fff';
                ctx.fillRect(screenX - poiSize/2, screenY - poiSize/2, poiSize, poiSize);
                
                // Draw POI name if discovered (or always for towns) (scale font with zoom)
                if ((poi.discovered || poi.type === 'town') && camera.zoom >= 0.8) {
                  ctx.fillStyle = '#fff';
                  ctx.font = `${Math.max(8, 8 * camera.zoom)}px sans-serif`;
                  ctx.textAlign = 'center';
                  ctx.fillText(poi.name, screenX, screenY - poiSize/2 - 4);
                }
              }
            }
          }
          
          // Draw rivers with variable width
          if (worldData.world.rivers) {
            for (const river of worldData.world.rivers) {
              if (river.points && river.points.length > 1) {
                // Draw river as a series of line segments with varying width
                for (let i = 0; i < river.points.length - 1; i++) {
                  const point1 = river.points[i];
                  const point2 = river.points[i + 1];
                  
                  // Calculate screen positions
                  const worldPosX1 = point1.x * baseTileSize;
                  const worldPosY1 = point1.y * baseTileSize;
                  const screenX1 = cx + (worldPosX1 - camera.x) * camera.zoom;
                  const screenY1 = cy + (worldPosY1 - camera.y) * camera.zoom;
                  
                  const worldPosX2 = point2.x * baseTileSize;
                  const worldPosY2 = point2.y * baseTileSize;
                  const screenX2 = cx + (worldPosX2 - camera.x) * camera.zoom;
                  const screenY2 = cy + (worldPosY2 - camera.y) * camera.zoom;
                  
                  // Use gradient for river color (darker blue at wider parts)
                  const avgWidth = (point1.width + point2.width) / 2;
                  const widthFactor = Math.min(avgWidth / 8, 1);
                  const blueValue = Math.floor(180 + widthFactor * 40);
                  ctx.strokeStyle = `rgb(59, 130, ${blueValue})`;
                  
                  // Scale line width based on point width and zoom
                  ctx.lineWidth = Math.max(1, avgWidth * camera.zoom);
                  ctx.lineCap = 'round';
                  ctx.lineJoin = 'round';
                  
                  ctx.beginPath();
                  ctx.moveTo(screenX1, screenY1);
                  ctx.lineTo(screenX2, screenY2);
                  ctx.stroke();
                }
              }
            }
          }
        } else {
          // Fallback: draw simple grid if no world data
          ctx.strokeStyle = '#222';
          ctx.lineWidth = 1;
          const gridSize = 32;
          
          const gridOffsetX = -camera.x % gridSize;
          const gridOffsetY = -camera.y % gridSize;
          
          for (let x = gridOffsetX; x < canvas.width; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
          }
          for (let y = gridOffsetY; y < canvas.height; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
          }
        }
        
        // Draw other players (with camera offset and zoom)
        ctx.fillStyle = '#718096';
        for (const p of others.values()) {
          const screenX = cx + (p.position.x - camera.x) * camera.zoom;
          const screenY = cy + (p.position.y - camera.y) * camera.zoom;
          
          // Only draw if on screen
          const playerSize = 12 * camera.zoom;
          if (screenX > -20 && screenX < canvas.width + 20 && 
              screenY > -20 && screenY < canvas.height + 20) {
            ctx.fillRect(screenX - playerSize/2, screenY - playerSize/2, playerSize, playerSize);
            // Draw name (only if zoomed in enough)
            if (camera.zoom >= 0.7) {
              ctx.fillStyle = '#aaa';
              ctx.font = `${Math.max(8, 10 * camera.zoom)}px sans-serif`;
              ctx.textAlign = 'center';
              ctx.fillText(p.name || p.userId, screenX, screenY - playerSize/2 - 4);
              ctx.fillStyle = '#718096';
            }
          }
        }
        
        // Draw player (always at center when camera is following)
        const playerScreenX = cx + (me.x - camera.x) * camera.zoom;
        const playerScreenY = cy + (me.y - camera.y) * camera.zoom;
        
        const myPlayerSize = 16 * camera.zoom;
        ctx.fillStyle = '#3b82f6';
        ctx.fillRect(playerScreenX - myPlayerSize/2, playerScreenY - myPlayerSize/2, myPlayerSize, myPlayerSize);
        
        // Draw player label
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${Math.max(10, 12 * camera.zoom)}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText('You', playerScreenX, playerScreenY - myPlayerSize/2 - 4);
      }
      
      function drawPOIInterior(cx, cy) {
        const interior = gameState.poiInteriors.get(gameState.currentPOI);
        if (!interior) return;
        
        // Add cave-specific background for dark atmosphere
        if (interior.type === 'dark_cave') {
          ctx.fillStyle = '#0f1419'; // Very dark blue-gray background
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // POI interior rendering
        const tileSize = 16 * camera.zoom; // Larger tiles for interior (tile units)
        
        // Calculate visible area
        const viewWidth = cx / camera.zoom;
        const viewHeight = cy / camera.zoom;
        const interiorWidth = interior.width || (interior.layout && interior.layout[0] ? interior.layout[0].length : 0);
        const interiorHeight = interior.height || (interior.layout ? interior.layout.length : 0);
        const startX = Math.max(0, Math.floor(camera.x - viewWidth / 16));
        const endX = Math.min(interiorWidth - 1, Math.ceil(camera.x + viewWidth / 16));
        const startY = Math.max(0, Math.floor(camera.y - viewHeight / 16));
        const endY = Math.min(interiorHeight - 1, Math.ceil(camera.y + viewHeight / 16));
        
        // Draw interior tiles
        for (let y = startY; y <= endY; y++) {
          for (let x = startX; x <= endX; x++) {
            const cell = interior.layout[y][x];
            // camera.x/y are in tile units for interiors; convert tile delta to pixels
            const screenX = cx + (x - camera.x) * tileSize;
            const screenY = cy + (y - camera.y) * tileSize;
            
            // Draw cell based on type
            ctx.fillStyle = getCellColor(cell.type);
            ctx.fillRect(screenX, screenY, tileSize, tileSize);
            
            // Draw walls/doors with borders
            if (cell.type === 'wall') {
              ctx.strokeStyle = '#000';
              ctx.lineWidth = 1;
              ctx.strokeRect(screenX, screenY, tileSize, tileSize);
            } else if (cell.type === 'door') {
              ctx.strokeStyle = '#8B4513';
              ctx.lineWidth = 2;
              ctx.strokeRect(screenX, screenY, tileSize, tileSize);
            }
          }
        }
        
        // Draw entities (NPCs)
        if (interior.entities) {
          for (const entity of interior.entities) {
            // Use tile delta times tileSize; camera.* are tile units
            const screenX = cx + (entity.position.x - camera.x) * tileSize;
            const screenY = cy + (entity.position.y - camera.y) * tileSize;
            const entitySize = 12 * camera.zoom;
            
            // Draw entity based on type and state
            ctx.fillStyle = getEntityColorFor(entity);
            if (entity.type === 'dragon_egg') {
              // Draw egg shape (ellipse)
              const eggWidth = entitySize * 0.8;
              const eggHeight = entitySize * 1.2;
              ctx.beginPath();
              ctx.ellipse(screenX, screenY, eggWidth/2, eggHeight/2, 0, 0, 2 * Math.PI);
              ctx.fill();
              // Add border for egg
              ctx.strokeStyle = '#b45309';
              ctx.lineWidth = 2;
              ctx.stroke();
            } else if (entity.type === 'bat') {
              // Draw small circle for bat
              ctx.beginPath();
              ctx.arc(screenX, screenY, entitySize * 0.3, 0, 2 * Math.PI);
              ctx.fill();
            } else if (entity.type === 'slime') {
              // Draw circle for slime
              ctx.beginPath();
              ctx.arc(screenX, screenY, entitySize * 0.4, 0, 2 * Math.PI);
              ctx.fill();
            } else if (entity.type === 'portal') {
              // Pulsing ring for ancient portal
              const t = performance.now() / 500;
              const r = entitySize * (0.6 + 0.15 * Math.sin(t));
              ctx.strokeStyle = getEntityColor('portal');
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(screenX, screenY, r, 0, 2 * Math.PI);
              ctx.stroke();
            } else if (entity.type === 'druid') {
              // Small green circle for druids
              ctx.fillStyle = getEntityColor('druid');
              ctx.beginPath();
              ctx.arc(screenX, screenY, entitySize * 0.35, 0, 2 * Math.PI);
              ctx.fill();
            } else if (entity.type === 'megalith') {
              // Upright stone slab
              ctx.fillStyle = getEntityColor('megalith');
              ctx.fillRect(screenX - (entitySize*0.2), screenY - entitySize*0.6, entitySize*0.4, entitySize*1.0);
            } else if (entity.type === 'altar') {
              // Small glowing square
              ctx.fillStyle = getEntityColor('altar');
              ctx.fillRect(screenX - entitySize*0.3, screenY - entitySize*0.3, entitySize*0.6, entitySize*0.6);
              ctx.strokeStyle = '#ffffffaa';
              ctx.lineWidth = 1;
              ctx.strokeRect(screenX - entitySize*0.3, screenY - entitySize*0.3, entitySize*0.6, entitySize*0.6);
            } else {
              // Draw regular NPC (rectangle)
              ctx.fillRect(screenX - entitySize/2, screenY - entitySize/2, entitySize, entitySize);
            }
            
            // Draw name if zoomed in
            if (camera.zoom >= 0.8) {
              ctx.fillStyle = '#fff';
              ctx.font = `${Math.max(10, 12 * camera.zoom)}px sans-serif`;
              ctx.textAlign = 'center';
              ctx.fillText(getEntityLabel(entity), screenX, screenY - entitySize/2 - 4);
            }
          }
        }
        
        // Draw player in interior
        const playerSize = 12 * camera.zoom;
        ctx.fillStyle = '#4a90e2'; // Blue player
        ctx.fillRect(cx - playerSize/2, cy - playerSize/2, playerSize, playerSize);
      }

      function drawBuildingInterior(cx, cy) {
        const bId = gameState.currentBuilding;
        if (!bId) return;
        const interior = gameState.buildingInteriors.get(bId);
        if (!interior) return;
        const tileSize = 16 * camera.zoom;
        const viewWidth = cx / camera.zoom;
        const viewHeight = cy / camera.zoom;
        const interiorWidth = interior.width || (interior.layout && interior.layout[0] ? interior.layout[0].length : 0);
        const interiorHeight = interior.height || (interior.layout ? interior.layout.length : 0);
        const startX = Math.max(0, Math.floor(camera.x - viewWidth / 16));
        const endX = Math.min(interiorWidth - 1, Math.ceil(camera.x + viewWidth / 16));
        const startY = Math.max(0, Math.floor(camera.y - viewHeight / 16));
        const endY = Math.min(interiorHeight - 1, Math.ceil(camera.y + viewHeight / 16));
        for (let y = startY; y <= endY; y++) {
          for (let x = startX; x <= endX; x++) {
            const cell = interior.layout[y][x];
            const screenX = cx + (x - camera.x) * tileSize;
            const screenY = cy + (y - camera.y) * tileSize;
            ctx.fillStyle = getCellColor(cell.type);
            ctx.fillRect(screenX, screenY, tileSize, tileSize);
            if (cell.type === 'wall') {
              ctx.strokeStyle = '#000';
              ctx.lineWidth = 1;
              ctx.strokeRect(screenX, screenY, tileSize, tileSize);
            } else if (cell.type === 'door') {
              ctx.strokeStyle = '#8B4513';
              ctx.lineWidth = 2;
              ctx.strokeRect(screenX, screenY, tileSize, tileSize);
            }
          }
        }
        if (interior.entities) {
          for (const entity of interior.entities) {
            const screenX = cx + (entity.position.x - camera.x) * tileSize;
            const screenY = cy + (entity.position.y - camera.y) * tileSize;
            const entitySize = 12 * camera.zoom;
            ctx.fillStyle = getEntityColorFor(entity);
            ctx.fillRect(screenX - entitySize/2, screenY - entitySize/2, entitySize, entitySize);
            if (camera.zoom >= 0.8) {
              ctx.fillStyle = '#fff';
              ctx.font = `${Math.max(10, 12 * camera.zoom)}px sans-serif`;
              ctx.textAlign = 'center';
              ctx.fillText(getEntityLabel(entity), screenX, screenY - entitySize/2 - 4);
            }
          }
        }
        const playerSize = 12 * camera.zoom;
        ctx.fillStyle = '#4a90e2';
        ctx.fillRect(cx - playerSize/2, cy - playerSize/2, playerSize, playerSize);
      }
      
      function getCellColor(cellType) {
        const colors = {
          // Village interior colors
          grass: '#65a30d',    // green
          road: '#92400e',     // brown
          house: '#374151',    // dark gray  
          tavern: '#7c2d12',   // dark brown
          shop: '#1e40af',     // blue
          door: '#8B4513',     // saddle brown
          
          // Cave interior colors (bright, clearly visible)
          wall: '#64748b',     // light gray (clearly visible)
          floor: '#94a3b8',    // lighter gray (walkable areas)
          entrance: '#fbbf24', // bright yellow (cave entrance)
          
          // Tower-specific cells
          stairs_up: '#22c55e',   // green stairs
          stairs_down: '#ef4444', // red stairs
        };
        return colors[cellType] || '#222';
      }
      
      function getEntityColor(entityType) {
        const colors = {
          villager: '#10b981',   // green
          merchant: '#f59e0b',   // orange
          guard: '#dc2626',      // red
          archmage: '#8b5cf6',   // purple
          adept: '#22d3ee',      // cyan
          dragon_egg: '#f59e0b', // golden egg
          keeper: '#eab308',     // yellow
          boat: '#0ea5e9',       // blue
          dragon: '#dc2626',     // red
          junior_dragon: '#f97316', // orange
          thrall: '#9ca3af',     // gray
          prisoner: '#60a5fa',   // blue
          gold_pile: '#eab308',  // yellow
          druid: '#16a34a',      // emerald
          megalith: '#94a3b8',   // slate
          altar: '#fde68a',      // pale gold
          portal: '#7c3aed',     // violet
          bat: '#6b7280',        // gray bat
          slime: '#22c55e'       // green slime
        };
        return colors[entityType] || '#6b7280';
      }

      // Choose color taking into account entity state (e.g., dragon type)
      function getEntityColorFor(entity) {
        if (!entity) return '#6b7280';
        if (entity.type === 'dragon' && entity.state && entity.state.dragonType) {
          const t = String(entity.state.dragonType);
          if (t === 'red') return '#ef4444';
          if (t === 'green') return '#22c55e';
          if (t === 'brown') return '#92400e';
          if (t === 'gold') return '#f59e0b';
        }
        return getEntityColor(entity.type);
      }

      function getEntityLabel(entity) {
        if (entity && entity.name) return entity.name;
        const map = {
          villager: 'Villager',
          merchant: 'Merchant',
          guard: 'Guard',
          archmage: 'Archmage',
          adept: 'Adept',
          keeper: 'Lighthouse Keeper',
          boat: 'Boat',
          dragon: 'Dragon',
          junior_dragon: 'Young Dragon',
          thrall: 'Thrall',
          prisoner: 'Prisoner',
          gold_pile: 'Gold',
          druid: 'Druid',
          megalith: 'Standing Stone',
          altar: 'Altar',
          portal: 'Ancient Portal',
          dragon_egg: 'Dragon Egg',
          bat: 'Bat',
          slime: 'Slime'
        };
        const t = entity && entity.type;
        if (t && map[t]) return map[t];
        if (t) return String(t).replace(/_/g, ' ').replace(/\b\w/g, (c) => c.toUpperCase());
        return 'Entity';
      }
      
      function drawUI() {
        // Debug info
        ctx.fillStyle = '#666';
        ctx.font = '10px monospace';
        ctx.textAlign = 'left';
        ctx.fillText(`World: ${Math.round(me.x)}, ${Math.round(me.y)}`, 10, 20);
        ctx.fillText(`Camera: ${Math.round(camera.x)}, ${Math.round(camera.y)}`, 10, 35);
        ctx.fillText(`Zoom: ${camera.zoom.toFixed(1)}x`, 10, 50);
        
        // Show current biome
        if (worldData && worldData.world && worldData.world.biomeMap) {
          const biomeMap = worldData.world.biomeMap;
          const worldTileX = Math.floor(me.x / 8);
          const worldTileY = Math.floor(me.y / 8);
          if (biomeMap[worldTileY] && biomeMap[worldTileY][worldTileX]) {
            const biome = biomeMap[worldTileY][worldTileX];
            const biomeInfo = BIOME_DATA[biome];
            const biomeName = biomeInfo ? biomeInfo.name : biome;
            ctx.fillText(`Biome: ${biomeName}`, 10, 65);
          }
        }
        
        if (gameState.currentPOI) {
          const currentInterior = gameState.poiInteriors.get(gameState.currentPOI);
          if (currentInterior) {
            if (currentInterior.type === 'dark_cave') {
              ctx.fillText(`Location: Cave Interior`, 10, 80);
            } else if (currentInterior.type === 'ruined_castle') {
              ctx.fillText(`Location: Ruined Castle Interior`, 10, 80);
            } else if (currentInterior.type === 'wizards_tower') {
              ctx.fillText(`Location: Wizard's Tower`, 10, 80);
            } else if (currentInterior.type === 'lighthouse') {
              ctx.fillText(`Location: Lighthouse`, 10, 80);
            } else if (currentInterior.type === 'village') {
              ctx.fillText(`Location: Village Interior`, 10, 80);
            } else if (currentInterior.type === 'town') {
              ctx.fillText(`Location: Town Interior`, 10, 80);
            } else {
              ctx.fillText(`Location: Interior`, 10, 80);
            }
          }
        }
        
        // Show interaction prompts
        gameState.nearbyPOI = findNearbyPOI();
        const nearbyEgg = findNearbyEgg();
        
        if (nearbyEgg) {
          // Dragon egg prompt (highest priority)
          ctx.fillStyle = '#ffff00';
          ctx.font = '14px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Press SPACE to pick up Dragon Egg', canvas.width / 2, canvas.height - 80);
        } else if (gameState.nearbyPOI && !gameState.currentPOI) {
          // POI entry prompts
          ctx.fillStyle = '#ffff00';
          ctx.font = '14px sans-serif';
          ctx.textAlign = 'center';
          if (gameState.nearbyPOI.type === 'village' || gameState.nearbyPOI.type === 'town') {
            ctx.fillText(`Press SPACE to enter ${gameState.nearbyPOI.name}`, canvas.width / 2, canvas.height - 80);
          } else if (gameState.nearbyPOI.type === 'dark_cave') {
            ctx.fillText(`Press SPACE to enter ${gameState.nearbyPOI.name}`, canvas.width / 2, canvas.height - 80);
          } else if (gameState.nearbyPOI.type === 'ruined_castle') {
            ctx.fillText(`Press SPACE to enter ${gameState.nearbyPOI.name}`, canvas.width / 2, canvas.height - 80);
          } else if (gameState.nearbyPOI.type === 'wizards_tower') {
            ctx.fillText(`Press SPACE to enter ${gameState.nearbyPOI.name}`, canvas.width / 2, canvas.height - 80);
          } else if (gameState.nearbyPOI.type === 'lighthouse') {
            ctx.fillText(`Press SPACE to enter ${gameState.nearbyPOI.name}`, canvas.width / 2, canvas.height - 80);
          } else if (gameState.nearbyPOI.type === 'dragon_grounds') {
            ctx.fillText(`Press SPACE to enter ${gameState.nearbyPOI.name}`, canvas.width / 2, canvas.height - 80);
          } else if (gameState.nearbyPOI.type === 'ancient_circle') {
            ctx.fillText(`Press SPACE to enter ${gameState.nearbyPOI.name}`, canvas.width / 2, canvas.height - 80);
          }
        } else if (gameState.currentPOI) {
          // Exit prompt
          ctx.fillStyle = '#ffff00';
          ctx.font = '14px sans-serif';
          ctx.textAlign = 'center';
          const currentInterior = gameState.poiInteriors.get(gameState.currentPOI);
          if (currentInterior && currentInterior.type === 'dark_cave') {
            ctx.fillText('Press SPACE to exit cave', canvas.width / 2, canvas.height - 80);
          } else if (currentInterior && currentInterior.type === 'ruined_castle') {
            ctx.fillText('Press SPACE to exit castle', canvas.width / 2, canvas.height - 80);
          } else if (currentInterior && currentInterior.type === 'wizards_tower') {
            // If near stairs, show stair prompt instead
            const stair = findNearbyStairs();
            if (stair === 'up') {
              ctx.fillText('Press SPACE to go up', canvas.width / 2, canvas.height - 80);
            } else if (stair === 'down') {
              ctx.fillText('Press SPACE to go down', canvas.width / 2, canvas.height - 80);
            } else {
              ctx.fillText('Press SPACE to exit tower', canvas.width / 2, canvas.height - 80);
            }
          } else {
            ctx.fillText('Press SPACE to exit village', canvas.width / 2, canvas.height - 80);
          }
        }
      }
      
      function drawMinimap() {
        if (minimapState === 'hidden' || !worldData || !worldData.world.biomeMap) return;
        
        minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
        
        const biomeMap = worldData.world.biomeMap;
        const worldSize = worldData.world.size;
        const canvasWidth = minimapCanvas.width;
        const canvasHeight = minimapCanvas.height;
        
        // Calculate scale to fit world in minimap
        const scale = Math.min(canvasWidth / worldSize, canvasHeight / worldSize);
        const offsetX = (canvasWidth - worldSize * scale) / 2;
        const offsetY = (canvasHeight - worldSize * scale) / 2;
        
        // Draw biome tiles (sample every few tiles for performance)
        const step = minimapState === 'fullscreen' ? 2 : 4;
        for (let y = 0; y < worldSize; y += step) {
          for (let x = 0; x < worldSize; x += step) {
            const biome = biomeMap[y] && biomeMap[y][x];
            if (biome && BIOME_DATA[biome]) {
              // Use base color for minimap (less variance for cleaner overview)
              minimapCtx.fillStyle = BIOME_DATA[biome].baseColor;
              const pixelX = offsetX + x * scale;
              const pixelY = offsetY + y * scale;
              const pixelSize = Math.max(1, scale * step);
              minimapCtx.fillRect(pixelX, pixelY, pixelSize, pixelSize);
            }
          }
        }
        
        // Draw POIs
        if (worldData.world.pois) {
          for (const poi of worldData.world.pois) {
            const pixelX = offsetX + poi.position.x * scale;
            const pixelY = offsetY + poi.position.y * scale;
            
            minimapCtx.fillStyle = POI_COLORS[poi.type] || '#fff';
            const poiSize = minimapState === 'fullscreen' ? 6 : 3;
            minimapCtx.fillRect(pixelX - poiSize/2, pixelY - poiSize/2, poiSize, poiSize);
            
            // Draw POI outline
            minimapCtx.strokeStyle = '#000';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(pixelX - poiSize/2, pixelY - poiSize/2, poiSize, poiSize);
          }
        }
        
        // Draw rivers with variable width
        if (worldData.world.rivers) {
          for (const river of worldData.world.rivers) {
            if (river.points && river.points.length > 1) {
              // Draw river segments with varying width
              for (let i = 0; i < river.points.length - 1; i++) {
                const point1 = river.points[i];
                const point2 = river.points[i + 1];
                
                const pixelX1 = offsetX + point1.x * scale;
                const pixelY1 = offsetY + point1.y * scale;
                const pixelX2 = offsetX + point2.x * scale;
                const pixelY2 = offsetY + point2.y * scale;
                
                // Calculate width for minimap (scaled down)
                const avgWidth = (point1.width + point2.width) / 2;
                const minimapWidth = minimapState === 'fullscreen' 
                  ? Math.max(1, avgWidth * 0.5)
                  : Math.max(0.5, avgWidth * 0.25);
                
                // Darker blue for wider sections
                const widthFactor = Math.min(avgWidth / 8, 1);
                const blueValue = Math.floor(180 + widthFactor * 40);
                minimapCtx.strokeStyle = `rgb(59, 130, ${blueValue})`;
                minimapCtx.lineWidth = minimapWidth;
                minimapCtx.lineCap = 'round';
                
                minimapCtx.beginPath();
                minimapCtx.moveTo(pixelX1, pixelY1);
                minimapCtx.lineTo(pixelX2, pixelY2);
                minimapCtx.stroke();
              }
            }
          }
        }
        
        // Draw other players
        for (const p of others.values()) {
          const pixelX = offsetX + (p.position.x / 8) * scale;
          const pixelY = offsetY + (p.position.y / 8) * scale;
          
          minimapCtx.fillStyle = '#718096';
          const playerSize = minimapState === 'fullscreen' ? 4 : 2;
          minimapCtx.fillRect(pixelX - playerSize/2, pixelY - playerSize/2, playerSize, playerSize);
        }
        
        // Draw player position
        const playerPixelX = offsetX + (me.x / 8) * scale;
        const playerPixelY = offsetY + (me.y / 8) * scale;
        
        // Player dot
        minimapCtx.fillStyle = '#3b82f6';
        const playerSize = minimapState === 'fullscreen' ? 6 : 3;
        minimapCtx.fillRect(playerPixelX - playerSize/2, playerPixelY - playerSize/2, playerSize, playerSize);
        
        // Player outline
        minimapCtx.strokeStyle = '#fff';
        minimapCtx.lineWidth = 1;
        minimapCtx.strokeRect(playerPixelX - playerSize/2, playerPixelY - playerSize/2, playerSize, playerSize);
        
        // Draw view area indicator
        if (minimapState === 'fullscreen') {
          const viewWidth = canvas.width / 8 * scale;
          const viewHeight = canvas.height / 8 * scale;
          
          minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
          minimapCtx.lineWidth = 2;
          minimapCtx.strokeRect(
            playerPixelX - viewWidth/2,
            playerPixelY - viewHeight/2,
            viewWidth,
            viewHeight
          );
        }
      }
      
      // POI interaction functions
      function findNearbyPOI() {
        if (!worldData || !worldData.world.pois) return null;
        
        const INTERACTION_DISTANCE = 24; // pixels (3 tiles * 8 pixels)
        let closest = null;
        let closestDistance = Infinity;
        
        for (const poi of worldData.world.pois) {
          const poiPixelX = poi.position.x * 8;
          const poiPixelY = poi.position.y * 8;
          // Special entry rule for Lighthouse: must be at the door (south side)
          if (poi.type === 'lighthouse') {
            const doorX = poiPixelX;
            const doorY = poiPixelY + 8; // south edge
            const dx = Math.abs(me.x - doorX);
            const dy = me.y - poiPixelY; // must be south of center
            const doorDist = Math.hypot(me.x - doorX, me.y - doorY);
            const atDoor = dx <= 12 && dy >= 0 && doorDist <= 16; // narrow window at the door
            if (!atDoor) continue;
            const d = doorDist;
            if (d < closestDistance) { closest = poi; closestDistance = d; }
            continue;
          }
          const distance = Math.hypot(me.x - poiPixelX, me.y - poiPixelY);
          
          if (distance <= INTERACTION_DISTANCE && distance < closestDistance) {
            closest = poi;
            closestDistance = distance;
          }
        }
        
        return closest;
      }
      
      function handlePOIInteraction() {
        if (gameState.currentPOI) {
          // Exit nested building if inside one
          if (gameState.currentBuilding) { exitBuilding(); return; }
          // Check if we're near a dragon egg and can collect it
          const nearbyEgg = findNearbyEgg();
          if (nearbyEgg) {
            collectEgg(nearbyEgg);
          } else {
            // Enter town building if at door
            const b = findNearbyBuildingDoor();
            if (b) { enterBuilding(b); return; }
            // Wizards Tower stairs handling
            const stair = findNearbyStairs();
            if (stair) {
              changeTowerFloor(stair);
            } else {
              // Exit to overworld
              exitPOI();
            }
          }
        } else {
          // We're in overworld - try to enter nearby POI
          const nearbyPOI = findNearbyPOI();
          if (nearbyPOI && (nearbyPOI.type === 'village' || nearbyPOI.type === 'town')) {
            enterVillage(nearbyPOI);
          } else if (nearbyPOI && nearbyPOI.type === 'dark_cave') {
            enterCave(nearbyPOI);
          } else if (nearbyPOI && nearbyPOI.type === 'ruined_castle') {
            enterCastle(nearbyPOI);
          } else if (nearbyPOI && nearbyPOI.type === 'wizards_tower') {
            enterTower(nearbyPOI);
          } else if (nearbyPOI && nearbyPOI.type === 'lighthouse') {
            enterLighthouse(nearbyPOI);
          } else if (nearbyPOI && nearbyPOI.type === 'dragon_grounds') {
            enterDragonGrounds(nearbyPOI);
          } else if (nearbyPOI && nearbyPOI.type === 'ancient_circle') {
            enterAncientCircle(nearbyPOI);
          }
        }
      }

      function findNearbyBuildingDoor() {
        if (!gameState.currentPOI) return null;
        const interior = gameState.poiInteriors.get(gameState.currentPOI);
        if (!interior || interior.type !== 'town' || !interior.buildings) return null;
        const px = Math.floor(me.x);
        const py = Math.floor(me.y);
        for (const b of interior.buildings) {
          const dx = Math.abs(px - b.door.x);
          const dy = Math.abs(py - b.door.y);
          if (dx <= 1 && dy <= 1) return b;
        }
        return null;
      }

      function enterBuilding(b) {
        if (!socket) return;
        gameState.currentBuilding = b.id;
        socket.emit('enter-building', { poiId: gameState.currentPOI, buildingId: b.id, buildingType: b.type });
      }

      function exitBuilding() {
        gameState.currentBuilding = null;
      }
      
      function enterVillage(poi) {
        log('[SYSTEM] Entering ' + poi.name + '...');
        console.log('Entering village:', poi.id, 'Socket connected:', !!socket);
        console.log(`[DEBUG] Client position: (${me.x}, ${me.y}), POI position: (${poi.position.x * 8}, ${poi.position.y * 8})`);
        
        // Check if we have cached interior
        const cached = gameState.poiInteriors.get(poi.id);
        if (cached) {
          // Use cached interior
          console.log('Using cached interior');
          transitionToInterior(poi, cached);
        } else {
          // Request interior generation from server
          console.log('Requesting interior from server for POI:', poi.id);
          socket.emit('enter-poi', { poiId: poi.id });
          
          // Add timeout to detect if server doesn't respond
          setTimeout(() => {
            console.log('No response from server after 5 seconds');
            log('[ERROR] Village entry timed out - server may not be responding');
          }, 5000);
        }
      }
      
      function enterCave(poi) {
        log('[SYSTEM] Entering ' + poi.name + '...');
        console.log('Entering cave:', poi.id, 'Socket connected:', !!socket);
        
        // Check if we have cached interior
        const cached = gameState.poiInteriors.get(poi.id);
        if (cached) {
          // Use cached interior
          console.log('Using cached cave interior');
          transitionToInterior(poi, cached);
        } else {
          // Request interior generation from server
          console.log('Requesting cave interior from server for POI:', poi.id);
          socket.emit('enter-poi', { poiId: poi.id });
          
          // Add timeout to detect if server doesn't respond
          setTimeout(() => {
            console.log('No response from server after 5 seconds');
            log('[ERROR] Cave entry timed out - server may not be responding');
          }, 5000);
        }
      }

      function enterTower(poi) {
        log('[SYSTEM] Entering ' + poi.name + '...');
        console.log('Entering wizard\'s tower:', poi.id, 'Socket connected:', !!socket);
        const cached = gameState.poiInteriors.get(poi.id);
        if (cached) {
          console.log('Using cached tower interior');
          transitionToInterior(poi, cached);
        } else {
          console.log('Requesting tower interior from server for POI:', poi.id);
          socket.emit('enter-poi', { poiId: poi.id });
          setTimeout(() => {
            console.log('No response from server after 5 seconds');
            log('[ERROR] Tower entry timed out - server may not be responding');
          }, 5000);
        }
      }

      function enterLighthouse(poi) {
        log('[SYSTEM] Entering ' + poi.name + '...');
        const cached = gameState.poiInteriors.get(poi.id);
        if (cached) {
          transitionToInterior(poi, cached);
        } else {
          socket.emit('enter-poi', { poiId: poi.id });
          setTimeout(() => log('[ERROR] Lighthouse entry timed out - server may not be responding'), 5000);
        }
      }

      function enterDragonGrounds(poi) {
        log('[SYSTEM] Entering ' + poi.name + '...');
        const cached = gameState.poiInteriors.get(poi.id);
        if (cached) {
          transitionToInterior(poi, cached);
        } else {
          socket.emit('enter-poi', { poiId: poi.id });
          setTimeout(() => log('[ERROR] Dragon Grounds entry timed out - server may not be responding'), 5000);
        }
      }

      function enterAncientCircle(poi) {
        log('[SYSTEM] Entering ' + poi.name + '...');
        const cached = gameState.poiInteriors.get(poi.id);
        if (cached) {
          transitionToInterior(poi, cached);
        } else {
          socket.emit('enter-poi', { poiId: poi.id });
          setTimeout(() => log('[ERROR] Ancient Circle entry timed out - server may not be responding'), 5000);
        }
      }

      // Tower helper: detect nearby stairs (within 1 tile)
      function findNearbyStairs() {
        if (!gameState.currentPOI) return null;
        const interior = gameState.poiInteriors.get(gameState.currentPOI);
        if (!interior) return null;
        const x = Math.floor(me.x);
        const y = Math.floor(me.y);
        const cell = interior.layout[y]?.[x];
        if (!cell) return null;
        if (cell.type === 'stairs_up') return 'up';
        if (cell.type === 'stairs_down') return 'down';
        return null;
      }

      // Tower helper: change floors and update layout/entities accordingly
      function changeTowerFloor(direction) {
        const interior = gameState.poiInteriors.get(gameState.currentPOI);
        if (!interior || !interior.floors) return;
        const current = interior.currentFloor || 0;
        let next = current;
        if (direction === 'up' && current < interior.floors.length - 1) next = current + 1;
        if (direction === 'down' && current > 0) next = current - 1;
        if (next === current) return;
        const nextFloor = interior.floors[next];
        interior.currentFloor = next;
        interior.layout = nextFloor.layout;
        interior.entities = nextFloor.entities;
        interior.containers = nextFloor.containers;
        // Position player at counterpart stairs
        if (direction === 'up' && nextFloor.stairsDown) {
          me.x = nextFloor.stairsDown.x;
          me.y = nextFloor.stairsDown.y;
        } else if (direction === 'down' && nextFloor.stairsUp) {
          me.x = nextFloor.stairsUp.x;
          me.y = nextFloor.stairsUp.y;
        } else if (nextFloor.entrance) {
          me.x = nextFloor.entrance.x;
          me.y = nextFloor.entrance.y;
        }
        camera.x = me.x;
        camera.y = me.y;
        log(`[SYSTEM] Moved to tower floor ${next + 1}/${interior.floors.length}`);
      }

      function enterCastle(poi) {
        log('[SYSTEM] Entering ' + poi.name + '...');
        console.log('Entering ruined castle:', poi.id, 'Socket connected:', !!socket);
        
        const cached = gameState.poiInteriors.get(poi.id);
        if (cached) {
          console.log('Using cached castle interior');
          transitionToInterior(poi, cached);
        } else {
          console.log('Requesting castle interior from server for POI:', poi.id);
          socket.emit('enter-poi', { poiId: poi.id });
          setTimeout(() => {
            console.log('No response from server after 5 seconds');
            log('[ERROR] Castle entry timed out - server may not be responding');
          }, 5000);
        }
      }
      
      function findNearbyEgg() {
        if (!gameState.currentPOI) return null;
        const interior = gameState.poiInteriors.get(gameState.currentPOI);
        if (!interior || !interior.entities) return null;
        
        // Find dragon eggs within 1.5 tiles of player
        // In interiors, me.x/me.y are already in tile units
        const playerTileX = Math.floor(me.x);
        const playerTileY = Math.floor(me.y);
        
        for (const entity of interior.entities) {
          if (entity.type === 'dragon_egg') {
            const dx = Math.abs(entity.position.x - playerTileX);
            const dy = Math.abs(entity.position.y - playerTileY);
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= 1.5) {
              return entity;
            }
          }
        }
        return null;
      }
      
      function collectEgg(egg) {
        log('[SYSTEM] Picking up Dragon Egg!');
        console.log('Collecting egg:', egg.id);
        
        // Remove egg from interior locally (optimistic update)
        const interior = gameState.poiInteriors.get(gameState.currentPOI);
        if (interior) {
          interior.entities = interior.entities.filter(e => e.id !== egg.id);
        }
        
        // TODO: Send egg collection to server for persistence and inventory
        // socket.emit('collect-egg', { eggId: egg.id, poiId: gameState.currentPOI });
      }
      
      function exitPOI() {
        log('[SYSTEM] Leaving village...');
        
        // Restore overworld position
        if (gameState.overworldPosition) {
          me.x = gameState.overworldPosition.x;
          me.y = gameState.overworldPosition.y;
          camera.x = me.x;
          camera.y = me.y;
        }
        
        gameState.currentPOI = null;
        gameState.overworldPosition = null;
      }
      
      function transitionToInterior(poi, interior) {
        // Store current overworld position
        gameState.overworldPosition = { x: me.x, y: me.y };
        
        gameState.currentPOI = poi.id;
        // Set player to interior entrance coordinates (keep in grid space)
        console.log('Entering POI:', poi.name, 'entrance:', interior.entrance);
        me.x = interior.entrance.x;
        me.y = interior.entrance.y;
        camera.x = me.x;
        camera.y = me.y;
        console.log('Player position set to:', me.x, me.y);
      }
      
      // Movement setup - Initialize once, outside of socket setup
      const speed = 100; // pixels per second (matches server MAX_SPEED)
      let keys = new Set();
      
      window.onkeydown = (e) => {
        // Don't capture keys when typing in chat
        if (e.target.id === 'chat') return;
        
        // Handle spacebar for POI interaction
        if (e.key === ' ' || e.key === 'Space') {
          e.preventDefault();
          handlePOIInteraction();
          return;
        }
        
        keys.add(e.key.toLowerCase());
      };
      
      window.onkeyup = (e) => {
        keys.delete(e.key.toLowerCase());
      };
      
      // Movement tick loop
      let last = performance.now();
      function tick(t) {
        const dt = (t - last) / 1000;
        last = t;
        
        let dx = 0, dy = 0;
        // Different movement speeds for different coordinate systems
        const currentSpeed = gameState.currentPOI ? 3 : speed; // Grid units per second for interiors
        if (keys.has('arrowup') || keys.has('w')) dy -= currentSpeed * dt;
        if (keys.has('arrowdown') || keys.has('s')) dy += currentSpeed * dt;
        if (keys.has('arrowleft') || keys.has('a')) dx -= currentSpeed * dt;
        if (keys.has('arrowright') || keys.has('d')) dx += currentSpeed * dt;
        
        if ((dx || dy) && socket) {
          if (gameState.currentPOI) {
            // Interior movement - purely client-side, no server updates
            const newX = me.x + dx;
            const newY = me.y + dy;
            
            if (isWalkable(newX, newY)) {
              me.x = newX;
              me.y = newY;
            } else {
              // Try moving only in one direction if diagonal movement is blocked
              if (isWalkable(me.x + dx, me.y)) {
                me.x += dx;
              } else if (isWalkable(me.x, me.y + dy)) {
                me.y += dy;
              }
            }
          } else {
            // Overworld movement - update server position
            const newX = me.x + dx;
            const newY = me.y + dy;
            
            if (isWalkable(newX, newY)) {
              me.x = newX;
              me.y = newY;
              socket.emit('move-player', { x: me.x, y: me.y, t: Date.now() });
            } else {
              // Try moving only in one direction if diagonal movement is blocked
              if (isWalkable(me.x + dx, me.y)) {
                me.x += dx;
                socket.emit('move-player', { x: me.x, y: me.y, t: Date.now() });
              } else if (isWalkable(me.x, me.y + dy)) {
                me.y += dy;
                socket.emit('move-player', { x: me.x, y: me.y, t: Date.now() });
              }
            }
          }
        }
        
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);

      function setupSocket(seed) {
        if (socket) socket.disconnect();
        socket = io(`/world/${encodeURIComponent(seed)}`, { transports: ['websocket'], auth: {} });
        const status = document.getElementById('status');
        
        socket.on('connect', () => { 
          status.textContent = 'connected';
          status.className = 'connected';
          log('[SYSTEM] Connected to world: ' + seed);
          // Send testing flags if enabled
          if (ignoreTerrain) {
            socket.emit('testing-flags', { ignoreTerrain: true });
          }
          setupRegenListener();
          setupBuildingListeners();
        });
        
        socket.on('disconnect', (r) => { 
          status.textContent = 'disconnected';
          status.className = '';
          log('[SYSTEM] Disconnected: ' + r);
        });
        
        socket.on('welcome', (data) => { 
          me.x = data.you.position.x;
          me.y = data.you.position.y;
          me.userId = data.you.userId;
          
          // Set camera to spawn point
          camera.x = me.x;
          camera.y = me.y;
          
          const tileX = Math.floor(me.x / 8);
          const tileY = Math.floor(me.y / 8);
          const biome = worldData && worldData.world.biomeMap[tileY] && worldData.world.biomeMap[tileY][tileX];
          log('[SYSTEM] Welcome! Starting position: ' + Math.round(me.x) + ', ' + Math.round(me.y) + (biome ? ' (' + biome + ')' : ''));
        });
        
        socket.on('player-moved', (list) => {
          others.clear();
          for (const p of list) {
            // Don't add ourselves to the others list
            if (p.userId !== me.userId) {
              others.set(p.userId, p);
            }
          }
        });
        
        socket.on('chat-message', (m) => {
          log(`[${m.channel.toUpperCase()}] ${m.from.name || m.from.userId}: ${m.message}`);
        });
        
        // POI interior responses
        socket.on('poi-interior', (data) => {
          const { poiId, interior } = data;
          // Cache the interior
          gameState.poiInteriors.set(poiId, interior);
          // Find the POI for transition
          const poi = worldData.world.pois.find(p => p.id === poiId);
          if (poi) {
            transitionToInterior(poi, interior);
          }
        });
        
        socket.on('poi-entry-error', (data) => {
          log(`[ERROR] Could not enter POI: ${data.error}`);
        });
        
        socket.on('chunk-state', (st) => {
          log(`[CHUNK] Entered ${st.chunkId} (POIs: ${st.pois.length}, NPCs: ${st.npcs.length})`);
        });
        
        socket.on('poi-interaction', (p) => {
          log(`[POI] Interaction with ${p.poiId}: ${JSON.stringify(p.result || p.error)}`);
        });
        
        socket.on('breed-result', (r) => {
          log(`[BREED] Result at ${r.poiId}: ${JSON.stringify(r.offspring || r.error)}`);
        });
      }

      // Connect button
      document.getElementById('connect').onclick = async () => {
        const seed = document.getElementById('seed').value || 'alpha';
        
        // Load world data first
        try {
          log('[SYSTEM] Loading world data...');
          const response = await fetch(`/worlds/${encodeURIComponent(seed)}/manifest?compact=1`);
          worldData = await response.json();
          log(`[SYSTEM] Loaded world: ${worldData.world.size}x${worldData.world.size}`);
        } catch (error) {
          log('[ERROR] Failed to load world data: ' + error.message);
        }
        
        setupSocket(seed);
        
        // Start rendering loop
        requestAnimationFrame(draw);
      };

      // Chat input
      document.getElementById('chat').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && socket && e.target.value.trim()) {
          const channel = document.getElementById('channel').value;
          const message = e.target.value.trim();
          socket.emit('chat-message', { channel, message });
          log(`[${channel.toUpperCase()}] You: ${message}`);
          e.target.value = '';
        }
      });

      // Debug buttons
      document.getElementById('interact').onclick = () => {
        if (!socket) {
          log('[ERROR] Not connected');
          return;
        }
        const poiId = 'poi:0:0:0:0';
        socket.emit('interact-poi', { poiId, action: 'discover' });
        log('[ACTION] Interacting with POI: ' + poiId);
      };
      
      document.getElementById('breed').onclick = () => {
        if (!socket) {
          log('[ERROR] Not connected');
          return;
        }
        const poiId = 'poi:0:0:1:0';
        socket.emit('breed-request', { poiId, parentAId: 'a1', parentBId: 'b2' });
        log('[ACTION] Breeding request at: ' + poiId);
      };

      // Ignore terrain toggle
      const ignoreBtn = document.getElementById('ignoreTerrainBtn');
      ignoreBtn.onclick = () => {
        ignoreTerrain = !ignoreTerrain;
        ignoreBtn.textContent = `Ignore Terrain: ${ignoreTerrain ? 'On' : 'Off'}`;
        log(`[TEST] Ignore terrain ${ignoreTerrain ? 'enabled' : 'disabled'}`);
        if (socket) socket.emit('testing-flags', { ignoreTerrain });
      };

      // Regenerate POI (dev): clears interior cache server-side and re-enters
      const regenBtn = document.getElementById('regenPoi');
      regenBtn.onclick = () => {
        if (!socket) { log('[ERROR] Not connected'); return; }
        let target = null;
        if (gameState.currentPOI) {
          target = gameState.currentPOI;
        } else {
          const near = findNearbyPOI();
          if (near) target = near.id;
        }
        if (!target) { log('[ERROR] No POI targeted (stand near or be inside)'); return; }
        log(`[TEST] Regenerating POI: ${target}`);
        gameState.poiInteriors.delete(target);
        socket.emit('regenerate-poi', { poiId: target });
        // If inside, request new interior right away
        if (gameState.currentPOI === target) {
          socket.emit('enter-poi', { poiId: target });
        }
      };

      // Acknowledge regeneration
      function setupRegenListener() {
        if (!socket) return;
        socket.on('poi-regenerated', (p) => {
          if (p.ok) {
            log(`[TEST] POI regenerated: ${p.poiId}`);
          } else {
            log(`[ERROR] Failed to regenerate POI: ${p.poiId}`);
          }
        });
      }

      // Building interior listeners
      function setupBuildingListeners() {
        if (!socket) return;
        socket.on('building-interior', (data) => {
          const { poiId, buildingId, interior } = data;
          if (poiId !== gameState.currentPOI || buildingId !== gameState.currentBuilding) return;
          gameState.buildingInteriors.set(buildingId, interior);
          me.x = interior.entrance.x;
          me.y = Math.max(0, interior.entrance.y - 1);
          camera.x = me.x;
          camera.y = me.y;
          log(`[SYSTEM] Entered building: ${buildingId}`);
        });
        socket.on('building-entry-error', (e) => {
          log(`[ERROR] Building entry failed: ${e.error}`);
          gameState.currentBuilding = null;
        });
      }
      
      // Hide controls hint after first movement
      let controlsShown = true;
      window.addEventListener('keydown', (e) => {
        if (controlsShown && ['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(e.key.toLowerCase())) {
          document.getElementById('controls').style.opacity = '0';
          setTimeout(() => {
            document.getElementById('controls').style.display = 'none';
          }, 300);
          controlsShown = false;
        }
      });
    </script>
  </body>
</html>
